{"version":3,"file":"VisualEditing.js","names":["VisualEditingComponent"],"sources":["../src/visual-editing/client-component/utils.ts","../src/visual-editing/client-component/VisualEditing.tsx"],"sourcesContent":["/**\n * From: https://github.com/vercel/next.js/blob/5469e6427b54ab7e9876d4c85b47f9c3afdc5c1f/packages/next/src/shared/lib/router/utils/path-has-prefix.ts#L10-L17\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */\nfunction pathHasPrefix(path: string, prefix: string): boolean {\n  if (typeof path !== 'string') {\n    return false\n  }\n\n  const {pathname} = parsePath(path)\n  return pathname === prefix || pathname.startsWith(`${prefix}/`)\n}\n\n/**\n * From: https://github.com/vercel/next.js/blob/5469e6427b54ab7e9876d4c85b47f9c3afdc5c1f/packages/next/src/shared/lib/router/utils/parse-path.ts#L6-L22\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nfunction parsePath(path: string): {\n  pathname: string\n  query: string\n  hash: string\n} {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return {pathname: path, query: '', hash: ''}\n}\n\n/**\n * From: https://github.com/vercel/next.js/blob/5469e6427b54ab7e9876d4c85b47f9c3afdc5c1f/packages/next/src/shared/lib/router/utils/add-path-prefix.ts#L3C1-L14C2\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string): string {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n  // If the path is exactly '/' then return just the prefix\n  if (path === '/' && prefix) {\n    return prefix\n  }\n\n  const {pathname, query, hash} = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n\n/**\n * From: https://github.com/vercel/next.js/blob/5469e6427b54ab7e9876d4c85b47f9c3afdc5c1f/packages/next/src/shared/lib/router/utils/remove-path-prefix.ts#L3-L39\n * Given a path and a prefix it will remove the prefix when it exists in the\n * given path. It ensures it matches exactly without containing extra chars\n * and if the prefix is not there it will be noop.\n *\n * @param path The path to remove the prefix from.\n * @param prefix The prefix to be removed.\n */\nexport function removePathPrefix(path: string, prefix: string): string {\n  // If the path doesn't start with the prefix we can return it as is. This\n  // protects us from situations where the prefix is a substring of the path\n  // prefix such as:\n  //\n  // For prefix: /blog\n  //\n  //   /blog -> true\n  //   /blog/ -> true\n  //   /blog/1 -> true\n  //   /blogging -> false\n  //   /blogging/ -> false\n  //   /blogging/1 -> false\n  if (!pathHasPrefix(path, prefix)) {\n    return path\n  }\n\n  // Remove the prefix from the path via slicing.\n  const withoutPrefix = path.slice(prefix.length)\n\n  // If the path without the prefix starts with a `/` we can return it as is.\n  if (withoutPrefix.startsWith('/')) {\n    return withoutPrefix\n  }\n\n  // If the path without the prefix doesn't start with a `/` we need to add it\n  // back to the path to make sure it's a valid path.\n  return `/${withoutPrefix}`\n}\n\n/**\n * From: https://github.com/vercel/next.js/blob/dfe7fc03e2268e7cb765dce6a89e02c831c922d5/packages/next/src/client/normalize-trailing-slash.ts#L16\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string, trailingSlash: boolean): string => {\n  const {pathname, query, hash} = parsePath(path)\n  if (trailingSlash) {\n    if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    }\n    return `${pathname}/${query}${hash}`\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n\n/**\n * From: https://github.com/vercel/next.js/blob/dfe7fc03e2268e7cb765dce6a89e02c831c922d5/packages/next/src/shared/lib/router/utils/remove-trailing-slash.ts#L8\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */\nfunction removeTrailingSlash(route: string) {\n  return route.replace(/\\/$/, '') || '/'\n}\n","import {\n  type HistoryAdapter,\n  type HistoryAdapterNavigate,\n  type HistoryRefresh,\n  VisualEditing as VisualEditingComponent,\n  type VisualEditingOptions,\n} from '@sanity/visual-editing/react'\nimport {usePathname, useRouter, useSearchParams} from 'next/navigation'\nimport {revalidateRootLayout} from 'next-sanity/visual-editing/server-actions'\nimport {useCallback, useEffect, useMemo, useRef, useState} from 'react'\n\nimport {addPathPrefix, normalizePathTrailingSlash, removePathPrefix} from './utils'\n\n/**\n * @public\n */\nexport interface VisualEditingProps extends Omit<VisualEditingOptions, 'history'> {\n  /**\n   * @deprecated The histoy adapter is already implemented\n   */\n  history?: never\n  /**\n   * If next.config.ts is configured with a basePath we try to configure it automatically,\n   * you can disable this by setting basePath to ''.\n   * @example basePath=\"/my-custom-base-path\"\n   * @alpha experimental and may change without notice\n   * @defaultValue process.env.__NEXT_ROUTER_BASEPATH || ''\n   */\n  basePath?: string\n  /**\n   * If next.config.ts is configured with a `trailingSlash` we try to detect it automatically,\n   * it can be controlled manually by passing a boolean.\n   * @example trailingSlash={true}\n   * @alpha experimental and may change without notice\n   * @defaultValue Boolean(process.env.__NEXT_TRAILING_SLASH)\n   */\n  trailingSlash?: boolean\n}\n\nexport default function VisualEditing(props: VisualEditingProps): React.JSX.Element | null {\n  const {basePath = '', plugins, components, refresh, trailingSlash = false, zIndex} = props\n\n  const router = useRouter()\n  const routerRef = useRef(router)\n  const [navigate, setNavigate] = useState<HistoryAdapterNavigate | undefined>()\n\n  useEffect(() => {\n    routerRef.current = router\n  }, [router])\n\n  const history = useMemo<HistoryAdapter>(\n    () => ({\n      subscribe: (_navigate) => {\n        setNavigate(() => _navigate)\n        return () => setNavigate(undefined)\n      },\n      update: (update) => {\n        switch (update.type) {\n          case 'push':\n            return routerRef.current.push(removePathPrefix(update.url, basePath))\n          case 'pop':\n            return routerRef.current.back()\n          case 'replace':\n            return routerRef.current.replace(removePathPrefix(update.url, basePath))\n          default:\n            throw new Error(`Unknown update type: ${update.type}`)\n        }\n      },\n    }),\n    [basePath],\n  )\n\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n  useEffect(() => {\n    if (navigate) {\n      navigate({\n        type: 'push',\n        url: normalizePathTrailingSlash(\n          addPathPrefix(`${pathname}${searchParams?.size ? `?${searchParams}` : ''}`, basePath),\n          trailingSlash,\n        ),\n      })\n    }\n  }, [basePath, navigate, pathname, searchParams, trailingSlash])\n\n  const handleRefresh = useCallback(\n    (payload: HistoryRefresh) => {\n      if (refresh) return refresh(payload)\n\n      const manualFastRefresh = () => {\n        // eslint-disable-next-line no-console\n        console.debug(\n          'Live preview is setup, calling router.refresh() to refresh the server components without refetching cached data',\n        )\n        routerRef.current.refresh()\n        return Promise.resolve()\n      }\n      const manualFallbackRefresh = () => {\n        // eslint-disable-next-line no-console\n        console.debug(\n          'No loaders in live mode detected, or preview kit setup, revalidating root layout',\n        )\n        return revalidateRootLayout()\n      }\n\n      const mutationFallbackRefresh = () => {\n        // eslint-disable-next-line no-console\n        console.debug(\n          'No loaders in live mode detected, or preview kit setup, revalidating root layout',\n        )\n        return revalidateRootLayout()\n      }\n\n      switch (payload.source) {\n        case 'manual':\n          return payload.livePreviewEnabled ? manualFastRefresh() : manualFallbackRefresh()\n        case 'mutation':\n          return payload.livePreviewEnabled ? mutationFastRefresh() : mutationFallbackRefresh()\n        default:\n          throw new Error('Unknown refresh source', {cause: payload})\n      }\n    },\n    [refresh],\n  )\n\n  return (\n    <VisualEditingComponent\n      plugins={plugins}\n      components={components}\n      history={history}\n      portal\n      refresh={handleRefresh}\n      zIndex={zIndex}\n    />\n  )\n}\n\nfunction mutationFastRefresh(): false {\n  // eslint-disable-next-line no-console\n  console.debug(\n    'Live preview is setup, mutation is skipped assuming its handled by the live preview',\n  )\n  return false\n}\n"],"mappings":"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"}