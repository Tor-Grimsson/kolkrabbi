{"version":3,"file":"index.js","names":[],"sources":["../../../../node_modules/.pnpm/@sanity+webhook@4.0.4/node_modules/@sanity/webhook/dist/index.mjs","../../src/webhook/index.ts"],"sourcesContent":["class WebhookSignatureValueError extends Error {\n  type = \"WebhookSignatureValueError\";\n  statusCode = 401;\n}\nclass WebhookSignatureFormatError extends Error {\n  type = \"WebhookSignatureFormatError\";\n  statusCode = 400;\n}\nfunction isSignatureError(error) {\n  return typeof error == \"object\" && error !== null && \"type\" in error && [\"WebhookSignatureValueError\", \"WebhookSignatureFormatError\"].includes(\n    error.type\n  );\n}\nconst MINIMUM_TIMESTAMP = 16094592e5, SIGNATURE_HEADER_REGEX = /^t=(\\d+)[, ]+v1=([^, ]+)$/, SIGNATURE_HEADER_NAME = \"sanity-webhook-signature\";\nasync function assertValidSignature(stringifiedPayload, signature, secret) {\n  const { timestamp } = decodeSignatureHeader(signature), encoded = await encodeSignatureHeader(stringifiedPayload, timestamp, secret);\n  if (signature !== encoded)\n    throw new WebhookSignatureValueError(\"Signature is invalid\");\n}\nasync function isValidSignature(stringifiedPayload, signature, secret) {\n  try {\n    return await assertValidSignature(stringifiedPayload, signature, secret), !0;\n  } catch (err) {\n    if (isSignatureError(err))\n      return !1;\n    throw err;\n  }\n}\nasync function assertValidRequest(request, secret) {\n  const signature = request.headers[SIGNATURE_HEADER_NAME];\n  if (Array.isArray(signature))\n    throw new WebhookSignatureFormatError(\"Multiple signature headers received\");\n  if (typeof signature != \"string\")\n    throw new WebhookSignatureValueError(\"Request contained no signature header\");\n  if (typeof request.body > \"u\")\n    throw new WebhookSignatureFormatError(\"Request contained no parsed request body\");\n  if (typeof request.body == \"string\" || Buffer.isBuffer(request.body))\n    await assertValidSignature(request.body.toString(\"utf8\"), signature, secret);\n  else\n    throw new Error(\n      \"[@sanity/webhook] `request.body` was not a string/buffer - this can lead to invalid signatures. See the [migration docs](https://github.com/sanity-io/webhook-toolkit#from-parsed-to-unparsed-body) for details on how to fix this.\"\n    );\n}\nasync function isValidRequest(request, secret) {\n  try {\n    return await assertValidRequest(request, secret), !0;\n  } catch (err) {\n    if (isSignatureError(err))\n      return !1;\n    throw err;\n  }\n}\nasync function encodeSignatureHeader(stringifiedPayload, timestamp, secret) {\n  const signature = await createHS256Signature(stringifiedPayload, timestamp, secret);\n  return `t=${timestamp},v1=${signature}`;\n}\nfunction decodeSignatureHeader(signaturePayload) {\n  if (!signaturePayload)\n    throw new WebhookSignatureFormatError(\"Missing or empty signature header\");\n  const [, timestamp, hashedPayload] = signaturePayload.trim().match(SIGNATURE_HEADER_REGEX) || [];\n  if (!timestamp || !hashedPayload)\n    throw new WebhookSignatureFormatError(\"Invalid signature payload format\");\n  return {\n    timestamp: parseInt(timestamp, 10),\n    hashedPayload\n  };\n}\nasync function createHS256Signature(stringifiedPayload, timestamp, secret) {\n  if (typeof crypto > \"u\")\n    throw new TypeError(\n      \"The Web Crypto API is not available in this environment, either polyfill `globalThis.crypto` or downgrade to `@sanity/webhook@3` which uses the Node.js `crypto` module.\"\n    );\n  if (!secret || typeof secret != \"string\")\n    throw new WebhookSignatureFormatError(\"Invalid secret provided\");\n  if (!stringifiedPayload)\n    throw new WebhookSignatureFormatError(\"Can not create signature for empty payload\");\n  if (typeof stringifiedPayload != \"string\")\n    throw new WebhookSignatureFormatError(\"Payload must be a JSON-encoded string\");\n  if (typeof timestamp != \"number\" || isNaN(timestamp) || timestamp < MINIMUM_TIMESTAMP)\n    throw new WebhookSignatureFormatError(\n      \"Invalid signature timestamp, must be a unix timestamp with millisecond precision\"\n    );\n  const enc = new TextEncoder(), key = await crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(secret),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    !1,\n    [\"sign\"]\n  ), signaturePayload = `${timestamp}.${stringifiedPayload}`, signature = await crypto.subtle.sign(\"HMAC\", key, enc.encode(signaturePayload)), signatureArray = Array.from(new Uint8Array(signature));\n  return btoa(String.fromCharCode.apply(null, signatureArray)).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction requireSignedRequest(options) {\n  const parseBody = typeof options.parseBody > \"u\" ? !0 : options.parseBody, respondOnError = typeof options.respondOnError > \"u\" ? !0 : options.respondOnError;\n  return async function(request, response, next) {\n    try {\n      await assertValidRequest(request, options.secret), parseBody && typeof request.body == \"string\" && (request.body = JSON.parse(request.body)), next();\n    } catch (err) {\n      if (!respondOnError || !isSignatureError(err)) {\n        next(err);\n        return;\n      }\n      response.status(err.statusCode).json({ message: err.message });\n    }\n  };\n}\nexport {\n  SIGNATURE_HEADER_NAME,\n  WebhookSignatureFormatError,\n  WebhookSignatureValueError,\n  assertValidRequest,\n  assertValidSignature,\n  decodeSignatureHeader,\n  encodeSignatureHeader,\n  isSignatureError,\n  isValidRequest,\n  isValidSignature,\n  requireSignedRequest\n};\n//# sourceMappingURL=index.mjs.map\n","import type {SanityDocument} from '@sanity/types'\nimport {isValidSignature, SIGNATURE_HEADER_NAME} from '@sanity/webhook'\nimport type {NextRequest} from 'next/server'\n\n/** @public */\nexport type ParsedBody<T> = {\n  /**\n   * If a secret is given then it returns a boolean. If no secret is provided then no validation is done on the signature, and it'll return `null`\n   */\n  isValidSignature: boolean | null\n  body: T | null\n}\n\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency = true,\n): Promise<ParsedBody<Body>> {\n  const signature = req.headers.get(SIGNATURE_HEADER_NAME)\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  const body = await req.text()\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 3000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n"],"x_google_ignoreList":[0],"mappings":"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"}