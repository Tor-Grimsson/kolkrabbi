import { isCorsOriginError } from "./isCorsOriginError.js";
import { sanitizePerspective } from "./utils.js";
import "@sanity/client";
import { preconnect, prefetchDNS } from "react-dom";
import SanityLiveClientComponent from "next-sanity/live/client-components/live";
import SanityLiveStreamClientComponent from "next-sanity/live/client-components/live-stream";
import { cookies, draftMode } from "next/headers";
import { perspectiveCookieName } from "@sanity/preview-url-secret/constants";
import { jsx } from "react/jsx-runtime";
async function resolveCookiePerspective() {
	return (await draftMode()).isEnabled ? (await cookies()).has(perspectiveCookieName) ? sanitizePerspective((await cookies()).get(perspectiveCookieName)?.value, "drafts") : "drafts" : "published";
}
function defineLive(config) {
	const { client: _client, serverToken, browserToken, fetchOptions, stega: stegaEnabled = true } = config;
	if (!_client) throw new Error("`client` is required for `defineLive` to function");
	if (process.env.NODE_ENV !== "production" && !serverToken && serverToken !== false) console.warn("No `serverToken` provided to `defineLive`. This means that only published content will be fetched and respond to live events. You can silence this warning by setting `serverToken: false`.");
	if (process.env.NODE_ENV !== "production" && !browserToken && browserToken !== false) console.warn("No `browserToken` provided to `defineLive`. This means that live previewing drafts will only work when using the Presentation Tool in your Sanity Studio. To support live previewing drafts stand-alone, provide a `browserToken`. It is shared with the browser so it should only have Viewer rights or lower. You can silence this warning by setting `browserToken: false`.");
	const client = _client.withConfig({
		allowReconfigure: false,
		useCdn: false
	});
	const { token: originalToken } = client.config();
	const studioUrlDefined = typeof client.config().stega.studioUrl !== "undefined";
	const sanityFetch = async function sanityFetch$1({ query, params = {}, stega: _stega, tags = ["sanity"], perspective: _perspective, tag, requestTag = tag ?? "next-loader.fetch" }) {
		const stega = _stega ?? (stegaEnabled && studioUrlDefined && (await draftMode()).isEnabled);
		const perspective = _perspective ?? await resolveCookiePerspective();
		const useCdn = perspective === "published";
		const revalidate = fetchOptions?.revalidate !== void 0 ? fetchOptions.revalidate : process.env.NODE_ENV === "production" ? false : void 0;
		const { syncTags } = await client.fetch(query, await params, {
			filterResponse: false,
			perspective,
			stega: false,
			returnQuery: false,
			next: {
				revalidate,
				tags: [...tags, "sanity:fetch-sync-tags"]
			},
			useCdn,
			cacheMode: useCdn ? "noStale" : void 0,
			tag: [requestTag, "fetch-sync-tags"].filter(Boolean).join(".")
		});
		const cacheTags = [...tags, ...syncTags?.map((tag$1) => `sanity:${tag$1}`) || []];
		const { result, resultSourceMap } = await client.fetch(query, await params, {
			filterResponse: false,
			perspective,
			stega,
			token: perspective !== "published" && serverToken ? serverToken : originalToken,
			next: {
				revalidate,
				tags: cacheTags
			},
			useCdn,
			cacheMode: useCdn ? "noStale" : void 0,
			tag: requestTag
		});
		return {
			data: result,
			sourceMap: resultSourceMap || null,
			tags: cacheTags
		};
	};
	return {
		sanityFetch,
		SanityLive: async function SanityLive(props) {
			const { refreshOnMount, refreshOnFocus, refreshOnReconnect, tag, requestTag = tag, onError, onGoAway, intervalOnGoAway, revalidateSyncTags } = props;
			const { projectId, dataset, apiHost, apiVersion, useProjectHostname, requestTagPrefix } = client.config();
			const { isEnabled: isDraftModeEnabled } = await draftMode();
			const { origin } = new URL(client.getUrl("", false));
			preconnect(origin);
			prefetchDNS(origin);
			return /* @__PURE__ */ jsx(SanityLiveClientComponent, {
				projectId,
				dataset,
				apiHost,
				apiVersion,
				useProjectHostname,
				requestTagPrefix,
				requestTag,
				token: typeof browserToken === "string" && isDraftModeEnabled ? browserToken : void 0,
				draftModeEnabled: isDraftModeEnabled,
				draftModePerspective: await resolveCookiePerspective(),
				refreshOnMount,
				refreshOnFocus,
				refreshOnReconnect,
				onError,
				onGoAway,
				intervalOnGoAway,
				revalidateSyncTags
			});
		},
		SanityLiveStream: async function SanityLiveStream(props) {
			const { query, params, perspective: _perspective, stega: _stega, tags, children, tag, requestTag = tag ?? "next-loader.live-stream.fetch" } = props;
			const { data, sourceMap, tags: cacheTags } = await sanityFetch({
				query,
				params,
				tags,
				perspective: _perspective,
				stega: _stega,
				requestTag
			});
			const { isEnabled: isDraftModeEnabled } = await draftMode();
			if (isDraftModeEnabled) {
				const stega = _stega ?? (stegaEnabled && studioUrlDefined && (await draftMode()).isEnabled);
				const perspective = _perspective ?? await resolveCookiePerspective();
				const { projectId, dataset } = client.config();
				return /* @__PURE__ */ jsx(SanityLiveStreamClientComponent, {
					projectId,
					dataset,
					query,
					params: await params,
					perspective,
					stega,
					initial: children({
						data,
						sourceMap,
						tags: cacheTags
					}),
					children
				});
			}
			return children({
				data,
				sourceMap,
				tags: cacheTags
			});
		}
	};
}
export { defineLive, isCorsOriginError };

//# sourceMappingURL=live.js.map